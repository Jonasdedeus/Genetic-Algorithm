# -*- coding: utf-8 -*-
"""GeneticAlgorithm_[1301183615_JonasDeDeusGuterres].ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10k26v9iZUtXwFMZRixCMG7sk4PwcIw6t
"""

import pandas as pd # this library is using for finding a max and get index
import math # this library is using for cos and sin
import random # this library is to get the random numbers
import time # this lirary is to run the output in the tuple based on the second
from time import sleep # thus library is to support the time

def getPop(size_pop,size_chrom): #this function is to get the population from the chromosome
    arpop = [] # initialize a list of population with variable arpop
    for i in range(size_pop): # to give a condition for inserting the population until the list full
      archrom = [] # initialize a list of chromosome with variable archrom
      for j in range (size_chrom): # to give a condition for inserting the chromosome until the list full
        get = random.randint(0,9) # store the random number in variable get
        archrom.append(get) # add the store random number to list of chromosome
      arpop.append(archrom) # add the list of chromosome to the list of population   
    return arpop # return the all list of population

def encodingGenotype(archrom,size_chrom): # this function is to get the phenotype
    rmax_x1,rmin_x1 = 2,-1 # initialize the limit of x1 that given in the assignment
    rmax_x2,rmin_x2 = 1,-1 # initialize the limit of x2 that given in the assignment
    valright,valright1,valdiv=0,0,0 # define new variable for storing
    for i in range(size_chrom-1): #to give a condition until each chromosome is calculated
      b = i+1 # initialize the be for the power value 
      if i<=3: # give a condition until the end of first half calculation
        vd = 10**-b # variable vd is for storing the power of base 10
        vr = archrom[i]*vd # variable vr is to calculate the each chromosome times vd
        valright+=vr # variable valright is to store every addition of vr
        valdiv+=vd # variable valdiv is to store every addition of vd for division
      else:# else condition for the last half  calculation
        b = i-3 # to make the power value remain same as before
        vd = 10**-b # variable vd is for storing the power of base 10
        vr = archrom[i]*vd # variable vr is to calculate the each chromosome times vd
        valright1+=vr # variable valright1 is to store every addition of vr
    x1 = rmin_x1+((rmax_x1 - rmin_x1) / (9 * valdiv)) * valright #initialize the variable x1 to store the value of x1
    x2 = rmin_x2+((rmax_x2 - rmin_x2) / (9 * valdiv)) * valright1 #initialize the variable x1 to store the value of x2
    return [x1,x2] # return the genotype (x1,x2)

def function_h(archrom,size_chrom): # this function is to calculate the function of h using -h for minimization
    decode = encodingGenotype(archrom,size_chrom) # initialize decode variable to assign the function of encoding
    x1_val = decode[0] # initialize x1_val for the first index as x1
    x2_val = decode[1] # initialize x2_val for the first index as x2
    h = math.cos(x1_val)*math.sin(x2_val)-x1_val/x2_val**2 + 1 # variable h is to store the result
    return -h # return the h * -1 

def fitness(arpop,size_chrom): #this function to find the maxfitness by collect it in the array
    Total_fit = []  # initialize a list of all fitness with variable Total_fit
    for i in range(len(arpop)): # to give a condition until lenth of population
        Total_fit.append(function_h(arpop[i],size_chrom)) # add the result of calculation to the total fit
    return Total_fit # return the all of the fitness of population

def Findbestfitness(find): #this function is to get the best fitness from the calculation of function h
    get_index = pd.Series(find).idxmax() #this variable get_index is to store the the index of max fitness
    return get_index # return the index that store in get_index

def parentSelection(arpop,size_chrom): #parent selection with tornament selection method
    best = [] # initialize a list of best fitness with variable best
    for i in range(0,4): # to give the condition until the range of tour which is 4
        ind_chrom = arpop[random.randint(0,len(arpop)-1)] # initialize the ind_chrome to save the random index from list of population
        if (best == [] or function_h(ind_chrom,size_chrom) > function_h(best,size_chrom)):# the contidion is to check wheter the list of best is empty
        # or the result function - h in ind_chrom is greater than the result function - h in ind_chrom.
            best = ind_chrom # swap the value if the condition is meet.
    return best # return the best array.

def crossover(parent1, parent2): # crossover function
    probability = random.random() # initialize variable probability to get the random percentage
    if (probability < 0.71): # to give a condition if probability is greater than 0.71
        point_bounder1 = random.randint(0,1) # to make a first point randomly
        point_bounder2 = random.randint(4,7) # to make a second point randomly
        parent1 = parent1[:point_bounder1] + parent2[point_bounder1:point_bounder2] + parent1[point_bounder2:] # concatenate it from two point in parent 1
        parent2 = parent2[:point_bounder1] + parent1[point_bounder1:point_bounder2] + parent2[point_bounder2:] # concatenate it from two point in parent 2
    return [parent1, parent2] # retunn the result in array of parent 1 and parent 2

def mutation(child1, child2): # mutation function
    probability = random.random() # initialize variable probability to get the random percentage
    if (probability <= 0.01): # to give a condition if probability is greater than 0.01
        child1[random.randint(0,7)] = random.randint(0,9) # to assign the random index with random value of child 1
        child2[random.randint(0,7)] = random.randint(0,9) # to assign the random index with random value of child 2
    return child1, child2 # return child 1 and child 2

def gen_replacement(arpop,bf_chrome,size_chrom): # generational replacement function is to process and generate the new generation
    new_gen = [] # initialize a list of new generation with variable new_gen
    for i in range(0,1): # to give a condition for add the two new generation from best chromosome
        new_gen.append(arpop[bf_chrome]) # add the two new generation from best chromosome
    i = 0 #initialize i equal to zero
    while i <(len(arpop)-2): # give a condition i less that population -2 (to minimize the size of making it stable)
        check = True # assign the check as a true 
        parent1,parent2 = parentSelection(arpop,size_chrom),parentSelection(arpop,size_chrom) # assign parent 1 and parent 2 to the function of selection parent
        while check: # give a condition if check is true
            if (parent1 == parent2): # chech condition if there is same result of parent 1 and parent 2
                parent2 = parentSelection(arpop,size_chrom) # assing again parent 2 to the function of selection parent
            else: # else condition is the result of parent 2 is diferent with parent 1
                check = False # assign the check as false to finish the while
        offspring = crossover(parent1,parent2) # initialize off spring as a crossover result
        offspring = mutation(offspring[0],offspring[1]) # mutate the offsprint of child 1 and child 2 and store again in the offspring as updated
        new_gen+=offspring # add the last result of offspring to the new generation
        i+=2 # increase the i variable by adding to to make the looping of population size become stable.
    return new_gen # return the new generation list

pop =  int(input("Enter the number of population: ")) # initialize pop for inputting the size of population
generation = int(input("Enter the number of generation: ")) # initialize generation for inputting the stopping generation number
size_chrom = 8 # assign new variable of size chromosome as 8
population = getPop(pop,size_chrom) # assign new variable population to the function get population 
for i in range(generation): # to give a condition until all generation is completed calculating.
   best = fitness(population,size_chrom) # assign new variable best to function fitness
   bf_chrom = Findbestfitness(best) # assign new variable bf_chrom to the function findbestfitness
   best_fitness = function_h(population[bf_chrom],size_chrom) # assign new variable best_fitness to the function_h

# Save the ouput in one tuple the print it by using function join.
   one_tuple = ('{Generation -', str(i+1), '|', 'Best Chromossome: ', str(population[bf_chrom]), '|', 'Best Fitness: ', str(best_fitness),'|','Decode Chromosome (x1,x2):',str(encodingGenotype(population[bf_chrom],size_chrom)),'}')
   print('\r', ' '.join(one_tuple), end='')

# Change every 0.5 second
   time.sleep(0.05)

   population = gen_replacement(population,bf_chrom,size_chrom)# assign new variable population to the function generational replacement to proceed the next generation
print("\n\nThe last Generation") # print the string the last generation
print("************************") # print the star  
print("Best Chromossome:",population[bf_chrom])# print the best chromosome from population
print("Fitness: ",best_fitness) # print the best fitness
print("X1,x2: ",encodingGenotype(population[bf_chrom],size_chrom)) #print the x1 and x2 of encoding genotype function.